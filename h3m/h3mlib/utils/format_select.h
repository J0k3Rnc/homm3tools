// Created by John Åkerblom 2014-12-10

#ifndef __FORMAT_SELECT_H_DEF__
#define __FORMAT_SELECT_H_DEF__

//
// This file provides a macro interface for correctly accessing
// members of unions by selecting union based on the passed
// h3m format value. The code generated is unoptimized as the 
// format comparison is repeated in every macro use, at least
// in all MSVC compiler output I have looked at.
//
// Some alternatives:
// 1. Simply have separate handtailored code for each format version. This was
//    my initial approach and some code is still written like this. It was out
//    of frustration when improving the parsing for the map specifications part
//    of the format (ai, additional info) which is very long and has extra bytes 
//    for later versions added several places throughout that I decided to take
//    a different approach.
//    Pros: Optimized and conceptually simple.
//    Cons: This means a lot of copy-paste code as the only main difference is 
//          the type of the struct used, with most members being the same 
//          (offsets, which is handled automatically by the compiler being the 
//          only difference). Annoying to maintain as most changes need to be 
//          done 3 times (+x for any mod supported in the future).
// 
// 2. Have a macro that generates EVERYTHING, meaning there is only a single
//    format comparison after which code with the approriate offsets and members
//    generated by the macro is executed.
//    Pros: Optimized.
//    Cons: This means the only the disassembly will be available for debugging. 
//          Also even amongst these several ugly options it will look the 
//          ugliest and be the most cancerous to work with.
//    
// 3. Instead of using data structures that resemble the original data 
//    structures as closely as possible and are binary compatible where that can
//    reasonably be achieved, simply use the same structure for all versions of 
//    the game with extra members going unused for versions that do not use 
//    them. This means all offsets will always be the same.
//    Pros: Optimized and very simple, although will ALWAYS use more memory than 
//          needed for non-SOD/<mod supported in the future>. Of course still 
//          not more memory than non-dynamically allocated unions though.
//    Cons: Debatable. Resemblance to the actual structures is drastically 
//          decreased for non-SOD which can be viewed as a problem for a 
//          multitude of reasons but could be argued to be worth it. All binary
//          compatibility lost and could get ridiculous when supporting mods
//          that add many things or just supporting many mods that add different
//          things.
// 
// 4. Write a strange macro interface that no one understand what it does
//    (this file).
//    Pros: None? Well at least the CALLING code is pretty readable and short if
//          you don't instantly close your eyes when you see a macro being used.
//    Cons: Unoptimized, rough, causes dissapointment at MSVC and
//          life in general. At the end of the day though it's a matter of worst
//          case having to do a couple of unnecessary CMPs per macro use, which
//          is not exactly a lot of overhead in this context. Just a bit 
//          mentally challenged.
// 
// 5. Write the code in a language that is not from the 70s and actually 
//    supports dynamic structures/metaprogramming/auto auto auto
//    Pros: Potentially optimized, simple
//    Cons: None? ;)
//

#include "safe_read.h"

#ifdef _MSC_VER
    // Disable different array subscripts warning.
    // This warning triggers for the first argument of memcpy,
    // when it is a ternary with arrays of different sizes and uses
    // & style address of address of array. There is no actual issue 
    // in the memcpy usage here as size is separately specified for each 
    // respective structure.
#pragma warning(disable:4048)
#endif

// TODO support for HotA in all macros

//
// FS_*: Retrieve (rvalue of) AB member of format F
//
#define FS_ANY(A, B, FM) \
    ((H3M_FORMAT_ROE == FM)? A.roe.B : \
    (H3M_FORMAT_AB == FM)? A.ab.B : \
    A.sod.B)

#define FS_ABSOD(A, B, FM) \
    ((H3M_FORMAT_AB == FM)? A.ab.B : \
    A.sod.B)

#define FS_SOD(A, B, FM) \
    A.sod.B

#define FS_ANY_PTR(A, B, FM) \
    ((H3M_FORMAT_ROE == FM) ? A->roe.B : \
    (H3M_FORMAT_AB == FM) ? A->ab.B : \
    A->sod.B)

#define FS_ABSOD_PTR(A, B, FM) \
    ((H3M_FORMAT_AB == FM) ? A->ab.B : \
    A->sod.B)

#define FS_SOD_PTR(A, B, FM) \
    A->sod.B

#define FS_ANY_VOIDCAST(A, B, FM) \
    ((H3M_FORMAT_ROE == FM) ? (void *)A.roe.B : \
    (H3M_FORMAT_AB == FM) ? (void *)A.ab.B : \
    (H3M_FORMAT_HOTA == FM) ? (void *)A.hota.B : \
    (void *)A.sod.B)

#define FS_ABSOD_VOIDCAST(A, B, FM) \
    ((H3M_FORMAT_AB == FM) ? (void *)A.ab.B : \
    (H3M_FORMAT_HOTA == FM) ? (void *)A.hota.B : \
    (void *)A.sod.B)

#define FS_SOD_VOIDCAST(A, B, FM) \
    (H3M_FORMAT_HOTA != FM) ? (void *)A.sod.B : \
    (void *)A.hota.B

//
// FS_*_SIZEOF: Retrieve size of AB member of format F
//
#define FS_ANY_SIZEOF(A, B, FM) \
    ((H3M_FORMAT_ROE == FM) ? sizeof(A.roe.B) : \
    (H3M_FORMAT_AB == FM) ? sizeof(A.ab.B) : \
    (H3M_FORMAT_HOTA == FM) ? sizeof(A.hota.B) : \
    sizeof(A.sod.B))

#define FS_ABSOD_SIZEOF(A, B, FM) \
    ((H3M_FORMAT_AB == FM) ? sizeof(A.ab.B) : \
    (H3M_FORMAT_HOTA == FM) ? sizeof(A.hota.B) : \
    sizeof(A.sod.B))

#define FS_SOD_SIZEOF(A, B, FM) \
    (H3M_FORMAT_HOTA != FM) ? sizeof(A.sod.B) : \
    sizeof(A.hota.B)

//
// FS_*_ASSIGN: Assign value to AB member of format F
//
#define FS_ANY_ASSIGN(A, B, V, FM) \
    switch (FM) \
    { \
    case H3M_FORMAT_ROE: \
        A.roe.B = V; \
        break; \
    case H3M_FORMAT_AB: \
        A.ab.B = V; \
        break; \
    case H3M_FORMAT_SOD: \
    /* fall through */ \
    default: \
        A.sod.B = V; \
        break; \
    }

#define FS_ABSOD_ASSIGN(A, B, V, FM) \
    switch (FM) \
    { \
    case H3M_FORMAT_ROE: \
        break; \
    case H3M_FORMAT_AB: \
        A.ab.B = V; \
        break; \
    case H3M_FORMAT_SOD: \
    /* fall through */ \
    default: \
        A.sod.B = V; \
        break; \
    }

#define FS_SOD_ASSIGN(A, B, V, FM) \
    switch (FM) \
    { \
    case H3M_FORMAT_ROE: \
        break; \
    case H3M_FORMAT_AB: \
        break; \
    case H3M_FORMAT_SOD: \
    /* fall through */ \
    default: \
        A.sod.B = V; \
        break; \
    }

//
// FS_*_READ_SIZEOF: Read into AB member of format F the size of the member
//                   Supports arrays and other variables (not pointers, but
//                   there is no point in using this _SIZEOF macro for pointers)
//
// & operator seen here in &DESTA is redudant for arrays as there exists no such 
// thing as an implicit address of an array address, but it's not worth it to 
// use an additional macro separately for arrays as opposed to other variables
// just for that reason when it works for both like this.
#define FS_ANY_READ_SIZEOF(DESTA, DESTB, PAR, FM) \
    SAFE_READ_N(FS_ANY_VOIDCAST(&DESTA, DESTB, FM), FS_ANY_SIZEOF(DESTA, DESTB, FM), PAR)

#define FS_ABSOD_READ_SIZEOF(DESTA, DESTB, PAR, FM) \
    if (FM >= H3M_FORMAT_AB) { \
        SAFE_READ_N(FS_ABSOD_VOIDCAST(&DESTA, DESTB, FM), FS_ABSOD_SIZEOF(DESTA, DESTB, FM), PAR) \
    }

#define FS_SOD_READ_SIZEOF(DESTA, DESTB, PAR, FM) \
    if (FM >= H3M_FORMAT_SOD) { \
        SAFE_READ_N(FS_SOD_VOIDCAST(&DESTA, DESTB, FM), FS_SOD_SIZEOF(DESTA, DESTB, FM), PAR) \
    }

//
// FS_*_WRITE_SIZEOF: Write from AB member of format F the size of the member
//                    See FS_*_READ_SIZEOF for more details.
//
#define FS_ANY_WRITE_SIZEOF(SRCA, SRCB, F, FM) \
    fwrite(FS_ANY_VOIDCAST(&SRCA, SRCB, FM), FS_ANY_SIZEOF(SRCA, SRCB, FM), 1, F);

#define FS_ABSOD_WRITE_SIZEOF(SRCA, SRCB, F, FM) \
    if (FM >= H3M_FORMAT_AB) { \
        fwrite(FS_ABSOD_VOIDCAST(&SRCA, SRCB, FM), FS_ABSOD_SIZEOF(SRCA, SRCB, FM), 1, F); \
    }

#define FS_SOD_WRITE_SIZEOF(SRCA, SRCB, F, FM) \
    if (FM >= H3M_FORMAT_SOD) { \
        fwrite(FS_SOD_VOIDCAST(&SRCA, SRCB, FM), FS_SOD_SIZEOF(SRCA, SRCB, FM), 1, F); \
    }

//
// FS_*_READ_N: Read into AB member of format F N bytes
//
#define FS_ANY_READ_N(DESTA, DESTB, N, PAR, FM) \
    SAFE_READ_N(FS_ANY_VOIDCAST(&DESTA, DESTB, FM), N, PAR)

/*#define FS_ABSOD_READ_N(SRCA, SRCB, N, F, FM) \
    if (FM >= H3M_FORMAT_AB) \
    { \
        SAFE_READ_N(FS_ABSOD(&DESTA, DESTB, FM), RAW, RAW_SIZE, OFFSET, N) \
    }

#define FS_SOD_READ_N(SRCA, SRCB, N, F, FM) \
    if (FM >= H3M_FORMAT_SOD) \
    { \
        SAFE_READ_N(FS_SOD(&DESTA, DESTB, FM), RAW, RAW_SIZE, OFFSET, N) \
    }*/

//
// FS_*_WRITE_N: Write from AB member of format F N bytes
//
#define FS_ANY_WRITE_N(SRCA, SRCB, N, F, FM) \
    fwrite(FS_ANY_VOIDCAST(&SRCA, SRCB, FM), N, 1, F);

#define FS_ABSOD_WRITE_N(SRCA, SRCB, N, F, FM) \
    if (FM >= H3M_FORMAT_AB) { \
        fwrite(FS_ABSOD_VOIDCAST(&SRCA, SRCB, FM), N, 1, F); \
    }

#define FS_SOD_WRITE_N(SRCA, SRCB, N, F, FM) \
    if (FM >= H3M_FORMAT_SOD) { \
        fwrite(FS_SOD_VOIDCAST(&SRCA, SRCB, FM), N, 1, F); \
    }

//
// FS_*_CALL: Call A, and return on error, for the right formats
//
#define FS_ANY_CALL(A, FM) \
    if (0 != A) { \
        return 1; \
    } \

#define FS_ABSOD_CALL(A, FM) \
    if (FM >= H3M_FORMAT_AB) { \
        if (0 != A) { \
            return 1; \
        } \
    }

#define FS_SOD_CALL(A, FM) \
    if (FM >= H3M_FORMAT_SOD) { \
        if (0 != A) { \
            return 1; \
        } \
    }

#endif
